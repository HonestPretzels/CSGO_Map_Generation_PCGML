# Dataset Generation Pipeline

All the demos I used require having faceit API access. This should be obtainable for free from https://developers.faceit.com/. You will need google authenticator for 2FA. Once you have api access create a .env file in this directory and save your key in a variable called FACEIT_API_KEY.

1. Run FaceitLogScraper.py to get demo and meta data files. Usage is described in the comment at the top of the file. This will fetch batches of game demo files and save them as demo files as well as the metadata provided by faceit as json files.
2. Run demoParser.go to get sequences of seconds and round win data out of the demo files. The input and output is described in further detail in a comment at the top of the go file.
3. Run demo_parse_loader.py to get 30 second splits (data (num_splits, 30_seconds, 10_players, 23_data_points)), maps assigned to each split (maps (num_splits)), round winners (scores (num_splits)) for each split, and breakpoints that show which splits belong to which game (breakspoints (num_games, num_splits_per_round)). This step converts from full games to 30 second splits of gameplay. Each split is limited to the round that it started in so many of them will be padded.
4. Run  splits_to_images.py to convert to full data arrays. At this step we are converting the data from a simple array to map-space. i.e. We will be placing points on the minimap to signify where the players are at each section. Each layer identifies a different action/team combo. The specifics are described in a comment in the file.
5. Run layer_reduce.py to convert to reduced format. Use False to create data and True to create labels. This will be the dataset used to train the autoencoder. The reduced format removes all but the main map layer, and simplifies the player representation. The input will be a 3-layer map representation where layer 0 is the main map layer, layer 1 is a 1 in each position where a player from team 1 is, and layer 2 is a 1 in each position where a player from team 2 is. If you create labels you will get a 3-layer map representation where layer 0 is the main map layer and layer 1 and 2 are filled with the number of players alive on each team divided by 5. 
6. Pass the reduced layers to zeroRemover.py to generate remove 30 seconds splits with no players in them. This helps the accuracy of the predictor.
7. You can use a trained autoencoder checkpoint with encoder.py to create the training data for the predictor network.
8. MapLabelCreator.py can be used to label each split with the corresponding map. It takes reduced images in as input.
9. PlayerCountLabelCreator.py can be used to label each split with the average number of players alive in that split. It also takes reduced images in as input.